name: Release Quality Report

on:
  push:
    tags:
      - "v[0-9]*.0.0"
  workflow_dispatch:
    inputs:
      version:
        description: "Version/tag label to use"
        required: true
        default: "v0.0.0-test"

permissions:
  contents: write

jobs:
  release_report:
    runs-on: ubuntu-latest

    env:
      SONAR_ORG: ${{ secrets.SONAR_ORG }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8
        with:
          fetch-depth: 0

      - name: Resolve version (tag)
        id: version
        run: |
          set -euo pipefail
          git fetch --tags origin

          # if workflow_dispatch provides an input then we use it
          if [ -n "${{ github.event.inputs.version || '' }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "Using provided version: $VERSION"
          else
            # if triggered by tag push then use that tag
            if [ "${{ github.ref_type }}" = "tag" ] && [ -n "${{ github.ref_name }}" ]; then
              VERSION="${{ github.ref_name }}"
              echo "Using pushed tag: $VERSION"
            else
              # else pick the latest tag matching v*.0.0
              VERSION="$(git tag -l 'v*.0.0' --sort=-v:refname | head -n 1)"
              if [ -z "$VERSION" ]; then
                echo "::error::No tag matching v*.0.0 found."
                exit 1
              fi
              echo "Using latest v*.0.0 tag: $VERSION"
            fi
          fi

          echo "VERSION=$VERSION" >> "$GITHUB_ENV"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Install deps
        working-directory: frontend/conuwalks
        run: npm ci

      - name: Run Jest with coverage
        working-directory: frontend/conuwalks
        run: npm test -- --coverage

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@689fb39b34b9aa95ebc5f8f119343ddd51542402
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.organization=${{ secrets.SONAR_ORG }}
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.projectBaseDir=frontend/conuwalks
            -Dsonar.sources=src
            -Dsonar.tests=src
            -Dsonar.test.inclusions=src/**/*.test.ts,src/**/*.test.tsx
            -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/build/**
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.verbose=true

      - name: Generate SonarCloud report
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          VERSION: ${{ env.VERSION }}
        run: |
          set -euo pipefail
          mkdir -p out

          REPORT="out/Code-Quality-${VERSION}.md"

          # Pull metrics (expanded list like your original)
          #curl -s -u "${SONAR_TOKEN}:" \
          #  "https://sonarcloud.io/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=alert_status,ncloc,duplicated_lines_density,comment_lines_density,coverage,branch_coverage,line_coverage,tests,test_success_density,cognitive_complexity,complexity,sqale_index,sqale_rating,sqale_debt_ratio,bugs,vulnerabilities,code_smells,security_hotspots,reliability_rating,security_rating,maintainability_rating,new_bugs,new_vulnerabilities,new_code_smells,new_security_hotspots,new_coverage" \
          #  > out/metrics.json
          API_URL="https://sonarcloud.io/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=alert_status,ncloc,duplicated_lines_density,comment_lines_density,coverage,branch_coverage,line_coverage,tests,test_success_density,cognitive_complexity,complexity,sqale_index,sqale_rating,sqale_debt_ratio,bugs,vulnerabilities,code_smells,security_hotspots,reliability_rating,security_rating,maintainability_rating,new_bugs,new_vulnerabilities,new_code_smells,new_security_hotspots,new_coverage"

          #debug
          echo "Fetching SonarCloud measures..."
          echo "$API_URL"

          http_code="$(curl -sS -u "${SONAR_TOKEN}:" -o out/metrics.json -w "%{http_code}" "$API_URL")"
          echo "HTTP: $http_code"
          sed -n '1,120p' out/metrics.json

          if [ "$http_code" != "200" ]; then
            echo "::error::SonarCloud API failed (HTTP $http_code)"
            exit 1
          fi

          if jq -e '.errors? | length > 0' out/metrics.json >/dev/null; then
            echo "::error::SonarCloud returned errors:"
            jq -r '.errors[]?.msg' out/metrics.json || true
            exit 1
          fi

          if ! jq -e '.component.measures? | length > 0' out/metrics.json >/dev/null; then
            echo "::error::No measures returned. Check project key, permissions, or branch context."
            exit 1
          fi

          curl -s -u "${SONAR_TOKEN}:" \
            "https://sonarcloud.io/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&resolved=false&ps=10&s=SEVERITY&asc=false" \
            > out/issues.json || echo '{}' > out/issues.json

          metric () {
            jq -r --arg k "$1" '.component.measures[]? | select(.metric==$k) | .value' out/metrics.json | head -n 1
          }
          val_or_na () {
            v="$(metric "$1" || true)"
            if [ -z "$v" ] || [ "$v" = "null" ]; then echo "N/A"; else echo "$v"; fi
          }

          QUALITY_GATE="$(val_or_na alert_status)"
          LOC="$(val_or_na ncloc)"
          DUP="$(val_or_na duplicated_lines_density)"
          DOC="$(val_or_na comment_lines_density)"
          COV="$(val_or_na coverage)"
          BR_COV="$(val_or_na branch_coverage)"
          LN_COV="$(val_or_na line_coverage)"
          TESTS="$(val_or_na tests)"
          TEST_OK="$(val_or_na test_success_density)"

          CCO="$(val_or_na cognitive_complexity)"
          CPLX="$(val_or_na complexity)"
          DEBT_MIN="$(val_or_na sqale_index)"
          SQALE_RATING="$(val_or_na sqale_rating)"
          DEBT_RATIO="$(val_or_na sqale_debt_ratio)"

          BUGS="$(val_or_na bugs)"
          VULNS="$(val_or_na vulnerabilities)"
          SMELLS="$(val_or_na code_smells)"
          HOTSPOTS="$(val_or_na security_hotspots)"

          REL_RATING="$(val_or_na reliability_rating)"
          SEC_RATING="$(val_or_na security_rating)"
          MAIN_RATING="$(val_or_na maintainability_rating)"

          NEW_BUGS="$(val_or_na new_bugs)"
          NEW_VULNS="$(val_or_na new_vulnerabilities)"
          NEW_SMELLS="$(val_or_na new_code_smells)"
          NEW_HOTSPOTS="$(val_or_na new_security_hotspots)"
          NEW_COV="$(val_or_na new_coverage)"

          if echo "$DEBT_MIN" | grep -Eq '^[0-9]+(\.[0-9]+)?$'; then
            DEBT_INT=$(printf "%.0f" "$DEBT_MIN")
            HOURS=$((DEBT_INT / 60))
            MINS=$((DEBT_INT % 60))
            TECH_DEBT="${HOURS}h ${MINS}m"
          else
            TECH_DEBT="$DEBT_MIN"
          fi

          rating_letter () {
            case "$1" in
              1) echo "A" ;;
              2) echo "B" ;;
              3) echo "C" ;;
              4) echo "D" ;;
              5) echo "E" ;;
              *) echo "N/A" ;;
            esac
          }

          REL_LET="$(rating_letter "$REL_RATING")"
          SEC_LET="$(rating_letter "$SEC_RATING")"
          MAIN_LET="$(rating_letter "$MAIN_RATING")"

          {
            echo "# Code Quality and Security Report â€“ ${VERSION}"
            echo ""
            echo "**Release tag:** \`${VERSION}\`"
            echo "**Commit:** \`${GITHUB_SHA}\`"
            echo "**Generated (UTC):** \`$(date -u +'%Y-%m-%d %H:%M')\`"
            echo ""

            echo "## Quality Gate"
            echo "- Status: **${QUALITY_GATE}**"
            echo ""

            echo "## Size, Coverage & Tests"
            echo "| Metric | Value |"
            echo "|---|---:|"
            echo "| Lines of Code (ncloc) | ${LOC} |"
            echo "| Coverage (%) | ${COV} |"
            echo "| Line Coverage (%) | ${LN_COV} |"
            echo "| Branch Coverage (%) | ${BR_COV} |"
            echo "| Tests | ${TESTS} |"
            echo "| Test Success Density (%) | ${TEST_OK} |"
            echo ""

            echo "### New Code (if available)"
            echo "| Metric | Value |"
            echo "|---|---:|"
            echo "| New Coverage (%) | ${NEW_COV} |"
            echo "| New Bugs | ${NEW_BUGS} |"
            echo "| New Vulnerabilities | ${NEW_VULNS} |"
            echo "| New Code Smells | ${NEW_SMELLS} |"
            echo "| New Security Hotspots | ${NEW_HOTSPOTS} |"
            echo ""

            echo "## Complexity & Duplication"
            echo "| Metric | Value |"
            echo "|---|---:|"
            echo "| Cognitive Complexity | ${CCO} |"
            echo "| Cyclomatic Complexity | ${CPLX} |"
            echo "| Duplicated Lines (%) | ${DUP} |"
            echo "| Comment Density (%) | ${DOC} |"
            echo ""

            echo "## Maintainability & Technical Debt"
            echo "| Metric | Value |"
            echo "|---|---:|"
            echo "| Maintainability Rating | ${MAIN_LET} (${MAIN_RATING}) |"
            echo "| SQALE Rating | ${SQALE_RATING} |"
            echo "| SQALE Debt Ratio (%) | ${DEBT_RATIO} |"
            echo "| Technical Debt (est.) | ${TECH_DEBT} |"
            echo "| Code Smells | ${SMELLS} |"
            echo ""

            echo "## Reliability & Security"
            echo "| Metric | Value |"
            echo "|---|---:|"
            echo "| Reliability Rating | ${REL_LET} (${REL_RATING}) |"
            echo "| Security Rating | ${SEC_LET} (${SEC_RATING}) |"
            echo "| Bugs | ${BUGS} |"
            echo "| Vulnerabilities | ${VULNS} |"
            echo "| Security Hotspots | ${HOTSPOTS} |"
            echo ""

            echo "## Top Unresolved Issues (snapshot)"
            echo "_Top 10 unresolved issues (sorted by severity), at report generation time._"
            echo ""
            echo "| Severity | Type | Component | Line | Message |"
            echo "|---|---|---|---:|---|"
            jq -r '
              if (.issues // empty) == empty then empty
              else .issues[]
                | [
                    (.severity // "N/A"),
                    (.type // "N/A"),
                    (.component // "N/A"),
                    (.line // 0),
                    (.message // "N/A" | gsub("\\|"; "/") | .[0:120])
                  ]
                | @tsv
              end
            ' out/issues.json \
            | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' || true

            echo ""
            echo "## Notes"
            echo "- Report generated automatically from SonarCloud measures for the tagged release."
          } > "$REPORT"

      - name: Publish report to GitHub Wiki
        env:
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          git config --global user.email "github-actions@github.com"
          git config --global user.name "github-actions"

          test -f "out/Code-Quality-${VERSION}.md"

          # Authenticated wiki clone (works for private repos too)
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.wiki.git" wiki

          # Create one page per release (filename becomes wiki page title)
          cp "out/Code-Quality-${VERSION}.md" "wiki/Code-Quality-${VERSION}.md"

          cd wiki
          git add .
          git commit -m "Add SonarCloud quality report for ${VERSION}" || echo "No changes to commit."
          git push
